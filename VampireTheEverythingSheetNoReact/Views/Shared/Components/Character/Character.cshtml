@using Microsoft.AspNetCore.Html
@using Microsoft.AspNetCore.Razor.TagHelpers
@using VampireTheEverythingSheetNoReact.Models.Component
@using VampireTheEverythingSheetNoReact.Shared_Files
@using static VampireTheEverythingSheetNoReact.Shared_Files.VtEConstants

@model Character

@functions
{
    void UpdateRow(ref int row, RectangularControlModel model)
    {
        Task<IHtmlContent> task = Component.InvokeAsync(model.ViewComponentName, model);
        task.Wait();
        row += model.Height ?? 1;
        @(task.Result)
    }

    //void UpdateMaxRow<Model>(ref int row, IEnumerable<KeyValuePair<string, Model>> components) where Model : RectangularControlModel
    void UpdateMaxRow(ref int row, params RectangularControlModel[] components)
    {
        Task<IHtmlContent>[] tasks =
            (from RectangularControlModel component in components
             select Component.InvokeAsync(component.ViewComponentName, component)).ToArray();

        Task.WaitAll(tasks);

        row += Utils.Max(from component in components select (component.Height ?? 1));

        foreach (Task<IHtmlContent> task in tasks)
        {
            @(task.Result)
        }
    }

    IEnumerable<Task<IHtmlContent>> RenderMany(IEnumerable<Trait> traits)
    {
        return from Trait trait in traits select Component.InvokeAsync("TraitRenderer", trait);
    }
}

@{
    Character character = Model;

    //The number of columns outside the main layout on each side.
    const int borderWidth = 1;

    //The number of "bumper" columns between each content column.
    const int bumperWidth = 1;

    //The number of "real" columns, as the user will experience the page. This is a three-column layout, so this nuber is three.
    const int contentCols = 3;

    //The number of real columns that encompass each "content" column. In other words, the ratio between the width of the content columns and the HTML columns.
    const int contentColWidth = 11;

    //The number of real columns that encompass a sub-column. Sub-columns are used to create smaller UI elements like vital statistics.
    const int subColWidth = contentColWidth / 2;

    //The number of actual columns in the grid, including spacing columns and so on.
    const int realCols =
        (borderWidth * 2) +
        (bumperWidth * (contentCols - 1)) +
        (contentCols * contentColWidth);

    //The number of columns an element should span to encompass the entire width of the layout (minus the borders).
    const int mainContentColumnWidth = realCols - (borderWidth * 2);

    //The start point of each content column.
    const int leftColumn = borderWidth + 1;
    const int midColumn = leftColumn + contentColWidth + bumperWidth;
    const int rightColumn = midColumn + contentColWidth + bumperWidth;

    int[] columnIndices = new int[] { leftColumn, midColumn, rightColumn };

    int currentRow = 1;

    IEnumerable<Task<IHtmlContent>> topTextTraits = RenderMany(character.GetTraits(TraitCategory.TopText));

    IEnumerable<Task<IHtmlContent>> physicalAttributes = RenderMany(character.GetTraits(TraitCategory.Attribute, TraitSubCategory.Physical));
    IEnumerable<Task<IHtmlContent>> socialAttributes = RenderMany(character.GetTraits(TraitCategory.Attribute, TraitSubCategory.Mental));
    IEnumerable<Task<IHtmlContent>> mentalAttributes = RenderMany(character.GetTraits(TraitCategory.Attribute, TraitSubCategory.Social));

    IEnumerable<Task<IHtmlContent>> physicalSkills = RenderMany(character.GetTraits(TraitCategory.Skill, TraitSubCategory.Physical));
    IEnumerable<Task<IHtmlContent>> socialSkills = RenderMany(character.GetTraits(TraitCategory.Skill, TraitSubCategory.Social));
    IEnumerable<Task<IHtmlContent>> mentalSkills = RenderMany(character.GetTraits(TraitCategory.Skill, TraitSubCategory.Mental));

    IEnumerable<Task<IHtmlContent>> powers = RenderMany(character.GetTraits(TraitCategory.Power, TraitVisibility.Visible));

    IEnumerable<Trait> backgrounds = character.GetTraits(TraitCategory.Background);

    IEnumerable<Task<IHtmlContent>> progressions = RenderMany(character.GetTraits(TraitCategory.Progression));

    IEnumerable<Trait> meritsFlaws = character.GetTraits(TraitCategory.MeritFlaw);

    //we can't render these in advance because the view component needs access to the trait information anyway
    IEnumerable<Trait> specificPowers = character.GetTraits(TraitCategory.SpecificPower);

    IEnumerable<Task<IHtmlContent>> vitalStats = RenderMany(character.GetTraits(TraitCategory.VitalStatistic));

    //TODO:there has to be a better way of determining currentRow than what we're doing. Maybe using model objects we can pass by reference and get back RowsUsed or something?
    //TODO: Some or all of this style may be classable
}


<div class="d-grid text-center" style="grid-template-columns: repeat(@(realCols), minmax(0, 1fr)) !important; grid-auto-rows: max-content;">
    
    @{
        UpdateRow(ref currentRow, new AutoHeaderModel { Column = leftColumn, Width = mainContentColumnWidth, Row = currentRow, HeadingLevel = 1, HeadingText = character.GameTitle });
        UpdateRow(ref currentRow, new AutoGridModel
        {
            Column = leftColumn,
            Width = mainContentColumnWidth,
            Row = currentRow,
            ColumnCount = contentCols,
            BumperWidth = bumperWidth,
            Elements = topTextTraits
        });
        UpdateRow(ref currentRow, new AutoHeaderModel { Column = leftColumn, Width = mainContentColumnWidth, Row = currentRow, HeadingLevel = 2, HeadingText = "Attributes" });

        UpdateMaxRow(ref currentRow,
            new AutoColumnModel { Elements = physicalAttributes, Column = leftColumn, Width = contentColWidth, Row = currentRow, HeadingLevel = 3, HeadingText = "Physical" },
            new AutoColumnModel { Elements = socialAttributes, Column = midColumn, Width = contentColWidth, Row = currentRow, HeadingLevel = 3, HeadingText = "Social" },
            new AutoColumnModel { Elements = mentalAttributes, Column = rightColumn, Width = contentColWidth, Row = currentRow, HeadingLevel = 3, HeadingText = "Mental" }
        );

        UpdateRow(ref currentRow, new AutoHeaderModel { Column = leftColumn, Width = mainContentColumnWidth, Row = currentRow, HeadingLevel = 2, HeadingText = "Skills" });

        UpdateMaxRow(ref currentRow,
            new AutoColumnModel { Elements = physicalSkills, Column = leftColumn, Width = contentColWidth, Row = currentRow, HeadingLevel = 3, HeadingText = "Physical" },
            new AutoColumnModel { Elements = socialSkills, Column = midColumn, Width = contentColWidth, Row = currentRow, HeadingLevel = 3, HeadingText = "Social" },
            new AutoColumnModel { Elements = mentalSkills, Column = rightColumn, Width = contentColWidth, Row = currentRow, HeadingLevel = 3, HeadingText = "Mental" }
        );

        UpdateRow(ref currentRow, new AutoHeaderModel { Column = leftColumn, Width = mainContentColumnWidth, Row = currentRow, HeadingLevel = 2, HeadingText = "Advantages" });

        //TODO: UpdateRow and stuff from here on, fix graphical issues

        /*
        * The flow in this section works as such:
        *
        * - Powers (but not specific powers) are in the left column.
        * - Background, progression stats, and Merits and Flaws are in the middle column.
        * - Vital statistics, Path, Beliefs, and Nature Information are in the right column.
        *
        * All of these columns flow independently, and the longest of them determines the row of the next h2.
        * (We might actually consider if we can flow the specific powers onto the next "page," actually...)
        */

        UpdateMaxRow(ref currentRow,
            new AutoColumnModel { Elements = powers, Column = leftColumn, Width = contentColWidth, Row = currentRow, HeadingLevel = 3, HeadingText = "Powers" },
            new VerticalSequenceModel
            {
                Column = midColumn, Width = contentColWidth, Row = currentRow,
                Contents =
                [
                    //TODO: The rows on these don't actually matter. Consider making row an optional field. (Honestly we could refactor so most of the dimensions don't matter...)
                    new PickerColumnModel { Traits = backgrounds, Column = midColumn, Width = contentColWidth, Row = currentRow, HeadingLevel = 3, HeadingText = "Backgrounds" },
                    new AutoColumnModel { Elements = progressions, Column = midColumn, Width = contentColWidth, Row = currentRow },
                    new PickerColumnModel { Traits = meritsFlaws, Column = midColumn, Width = contentColWidth, Row = currentRow, HeadingLevel = 3, HeadingText = "Merits and Flaws" }
                ]
            },
            new VerticalSequenceModel
            {
                Column = rightColumn, Width = contentColWidth, Row = currentRow,
                Contents =
                [
                    //TODO: The rows on these don't actually matter. Consider making row an optional field. (Honestly we could refactor so most of the dimensions don't matter...)
                    new AutoGridModel { Column = rightColumn, Width = contentColWidth, Row = currentRow, ColumnCount = 2, BumperWidth = 1, Elements = vitalStats, HeadingLevel = 3, HeadingText = "Vital Statistics" }
                ]
            }
        );

        //TODO: Need to account separately for Vital Statistics and Morality being in one column - or reformat the page
        //this may involve ensuring that headers of a certain level are the same size as a rendered Trait
    }

</div>
